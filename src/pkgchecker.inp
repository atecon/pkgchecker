function scalar is_minimum_gretl_version (void)
    if $version >= 20205
        return TRUE
    else
        printError("At minimum Gretl version 2020e required.")
        return FALSE
    endif
end function

# FROM metadata
function scalar read_and_add_xml_buffer (bundle *self)
    /* Read gdt file which has a xml structure. */

    catch self.xml_buffer = readfile(self.filename)
    if $error
        printError(sprintf("Failed to read file '%s'. Abort.\n", self.filename))
        return TRUE
    else
        return FALSE
    endif
end function

# TODO: Really needed here? I don't think so
function string trim_extra_lines (const string buffer)
    /* */

    if nelem(buffer) == 0
        return buffer
    endif
    strings content = strsplit(buffer, "\n")

    scalar n = nelem(content)
    if n == 1
        return content[n]
    endif

    return content
end function


function string get_function_path (void)
    /* Configure path which should be parsed. */

    return "//gretl-functions/gretl-function-package"
end function


# FROM metadata
function string get_path_content (const string path "xpath identifier",
                                  const string xml_buffer,
                                  scalar *n_got "Number of occurences of path")
    /* Extract content of some path in xml. */

    string path_content

    path_content = xmlget(xml_buffer, path, &n_got)
    if $error
        printWarning(sprintf("Failed to find the path '%s'. Ignore.", path))
    endif

    return path_content
end function

function scalar get_number_of_functions (const bundle self)
    /* Get number of functions of package. */

    scalar n_functions = 0
    string path = sprintf("%s/gretl-function", get_function_path())
    string foo = get_path_content(path, self.xml_buffer, &n_functions)

    return n_functions
end function


function string get_path_code (const string function_path,
                               const int item[1::] "i-th function code")
    /* Compile path for retrieving code' for i-th function definition. */
    return sprintf("%s/gretl-function[%d]/code", function_path, item)
end function

function string get_path_code_name (const string function_path,
                                    const int item[1::] "i-th function code")
    /* Compile path for retrieving function's name for the i-th function definition. */
    return sprintf("%s/gretl-function[%d]/@name", function_path, item)
end function

function string get_function_name (const string function_path,
                                   const scalar item[1::] "i-th function code",
                                   const bundle self)
    /* Retrieve function name for the i-th function. */

    scalar n_got = 0
    string path = get_path_code_name(function_path, item)
    string function_name = get_path_content(path, self.xml_buffer, &n_got)

    return trim_extra_lines(function_name)
end function


function string get_code (const string function_path,
                          const scalar item[1::] "i-th function code",
                         const bundle self)
    /* Retrieve function name for the i-th function. */

    scalar n_got = 0
    string path = get_path_code(function_path, item)

    return get_path_content(path, self.xml_buffer, &n_got)
end function


function bundle extract_code_and_parameters (const bundle self)
    /* Compile a key-value store.
    key: Function name
    value: String holding the i-th function code */

    bundle Codes
    scalar n_functions = get_number_of_functions(self)

    if n_functions == 0
        printWarning("Package includes no functions.")
        return Codes
    endif

    loop i=1..n_functions
        string function_name = get_function_name(get_function_path(), $i, self)

        if nelem(function_name) == 0
            printWarning("Function not found. Ignore.")
            flush
        else
            Codes["@function_name"] = get_code(get_function_path(), $i, self)
        endif
    endloop

    assert(n_functions == nelem(Codes))

    return Codes
end function

function bundle get_pkgdata (const string filename "Path to gfn file")
    /* Main function */

    bundle self = null
    string self.filename = filename

    if !is_minimum_gretl_version()
        return null
    endif

    err = read_and_add_xml_buffer(&self)
    if err
        return null
    endif

    bundle Codes = extract_code_and_parameters(self)
    print Codes

    /*
    *** NEXT:
    A) Look at unused variables within a function
    1) Loop over each key (=function)
    2) Cast code for the i-th function as string array (\n as delimiter)
    3) extract assignments and check whether RHS variables is used
        somewhere or returned

    Codes (bundle)
        |-function_name1
            |-Code (string)
            |-parameter_names (string array)
                |- [Name1, Name2,..., NameN]
        |-function_name2
            |-Code (string)
            |-parameter_names (string array)
                |- [Name1, Name2,..., NameN]


    B) Apart from 'code' also parse names of params/param[i]/name
    1) Store 'name' as string array in Codes.input_parameters
    2) Loop over "code" and check whether input parameters are used in code

    C) For each function name (=key) iterate over code foreach other
        keys and check that the function is actually used somewhere. Of course,
        public functions won't be used within other functions...

    D) Write tests
    */
    eval getkeys(Codes)[11]
    eval Codes["print_auto_arima_results"]



    return self
end function


function void printInfo (const string s)
    printf "\nInfo: %s\n", s
end function

function void printWarning (const string s)
    printf "\nWarning: %s\n", s
end function

function void printError (const string s)
    printf "\nError: %s\n", s
end function
