function scalar is_minimum_gretl_version (void)
    if $version >= 20205
        return TRUE
    else
        printError("At minimum Gretl version 2020e required.")
        return FALSE
    endif
end function

# FROM metadata
function scalar read_and_add_xml_buffer (bundle *self)
    /* Read gdt file which has a xml structure. */

    catch self.xml_buffer = readfile(self.filename)
    if $error
        printError(sprintf("Failed to read file '%s'. Abort.\n", self.filename))
        return TRUE
    else
        return FALSE
    endif
end function

# TODO: Really needed here? I don't think so
function string trim_extra_lines (const string buffer)
    /* */

    if nelem(buffer) == 0
        return buffer
    endif
    strings content = strsplit(buffer, "\n")

    scalar n = nelem(content)
    if n == 1
        return content[n]
    endif

    return content
end function


function string get_function_path (void)
    /* Configure path which should be parsed. */

    return "//gretl-functions/gretl-function-package"
end function


# FROM metadata
function string get_path_content (const string path "xpath identifier",
                                  const string xml_buffer,
                                  scalar *n_got "Number of occurences of path")
    /* Extract content of some path in xml. */

    string path_content

    catch path_content = xmlget(xml_buffer, path, &n_got)
    if $error
        printWarning(sprintf("Failed to find the path '%s'. Ignore.", path))
    endif

    return path_content
end function

function scalar get_number_of_functions (const bundle self)
    /* Get number of functions of package. */

    scalar n_functions = 0
    scalar valid = TRUE
    scalar counter = 1

    loop while valid == TRUE
        scalar n_got = 0
        string path = get_path_code(get_function_path(), counter)
        string foo = get_path_content(path, self.xml_buffer, &n_got)

        if n_got
            n_functions++
            counter++
        else
            break
        endif
    endloop

    return n_functions
end function

function string get_path_code (const string function_path,
                               const int item[1::] "i-th function code")
    /* Compile path for retrieving code' for i-th function definition. */
    return sprintf("%s/gretl-function[%d]/code", function_path, item)
end function

function string get_path_code_name (const string function_path,
                                    const int item[1::] "i-th function code")
    /* Compile path for retrieving function's name for the i-th function definition. */
    return sprintf("%s/gretl-function[%d]/@name", function_path, item)
end function

function string get_code (const scalar item[1::] "i-th function code",
                          const bundle self)
    /* Retrieve function name for the i-th function. */

    scalar n_got = 0
    string path = get_path_code(get_function_path(), item)

    return get_path_content(path, self.xml_buffer, &n_got)
end function


function string get_path_count_parameters (const string function_path,
                                           const int item[1::] "i-th function code")
    return sprintf("%s/gretl-function[%d]/params/@count",\
                    function_path, item)
end function

function scalar get_number_of_parameters (const int item[1::],
                                          const bundle self)
    /* Get number of parameters for a specific functions. */

    scalar n_parameters = 0
    string path = get_path_count_parameters(get_function_path(), item)

    return atof(get_path_content(path, self.xml_buffer, &n_parameters))
end function

function string get_path_parameter_name (const string function_path,
                                         const int item[1::] "i-th function code",
                                         const int iparam[1::] "n-th parameter")
    /* Retrieve name of input parameter. */
    return sprintf("%s/gretl-function[%d]/params/param[%d]/@name",\
                    function_path, item, iparam)
end function


function strings get_parameter_names (const scalar item[1::] "i-th function",
                                      const bundle self)
    /* Retrieve function name for the i-th function. */

    scalar n_parameters = get_number_of_parameters(item, self)
    if ok(n_parameters)
        strings names = array(n_parameters)
    else
        return array(0) # function has void input
    endif

    loop i=1..n_parameters
        scalar n_got = 0
        string path = get_path_parameter_name(get_function_path(), item, i)
        names[i] = strstrip(get_path_content(path, self.xml_buffer, &n_got))
    endloop

    return names
end function



function string get_function_name (const scalar item[1::] "i-th function code",
                                   const bundle self)
    /* Retrieve function name for the i-th function. */

    scalar n_got = 0
    string path = get_path_code_name(get_function_path(), item)
    string function_name = get_path_content(path, self.xml_buffer, &n_got)

    return trim_extra_lines(function_name)
end function

function bundle extract_parameters (bundle Metadata,
                                    const bundle self)
    /* Extract input parameters for each function. */

    strings function_names = getkeys(Metadata)

    loop foreach i function_names
        Metadata["$i"].parameter_names = get_parameter_names(i, self)
    endloop

    return Metadata
end function


function bundle extract_code (const bundle self)
    /* Compile a key-value store.
    key: Function name
    value: String holding the i-th function code */

    bundle Codes
    scalar n_functions = get_number_of_functions(self)

    if n_functions == 0
        printWarning("Package includes no functions.")
        return Codes
    endif

    loop i=1..n_functions
        string function_name = get_function_name($i, self)

        if nelem(function_name) == 0
            printWarning("Function not found. Ignore.")
            flush
        else
            bundle Codes["@function_name"] = \
                        _(code = get_code($i, self))
        endif
    endloop

    assert(n_functions == nelem(Codes))

    return Codes
end function

function bundle get_pkgdata (const string filename "Path to gfn file",
                             const bool verbose[FALSE] "Print output")
    /* Main function */

    bundle self = null
    string self.filename = filename

    if !is_minimum_gretl_version()
        return null
    endif

    err = read_and_add_xml_buffer(&self)
    if err
        return null
    endif

    bundle Metadata = extract_code(self)
    if nelem(Metadata) == 0
        return self
    endif

    bundle Metadata = extract_parameters(Metadata, self)


    /*
    *** NEXT:
    A) Look at unused variables within a function
    1) Loop over each key (=function)
    2) Cast code for the i-th function as string array (\n as delimiter)
    3) extract assignments and check whether RHS variables is used
        somewhere or returned

    Codes (bundle)
        |-function_name1
            |-Code (string)
            |-parameter_names (string array)
                |- [Name1, Name2,..., NameN]
        |-function_name2
            |-Code (string)
            |-parameter_names (string array)
                |- [Name1, Name2,..., NameN]


    B) Apart from 'code' also parse names of params/param[i]/name
    1) Store 'name' as string array in Codes.input_parameters
    2) Loop over "code" and check whether input parameters are used in code

    */

    if verbose
        print_pkgchecker(Metadata)
    endif

    return Metadata
end function


# TODO: test
function bundle get_function_usages (const bundle Metadata)
    /* Check whether every function is actually called at least once.*/

    matrix graph = compile_dependency_graph(Metadata)
    matrix n_function_calls = summarize_graph(graph, getkeys(Metadata))

    strings uncalled_functions = get_uncalled_functions(n_function_calls)

    return _(graph, n_function_calls, uncalled_functions)
end function

function strings get_uncalled_functions (const matrix n_function_calls)
    /* Compile array holding names of functions which are not called in the package. NOTE: Such functions may be public ones. */

    strings function_names = rnameget(n_function_calls)
    strings uncalled = array(0)

    if sumc((n_function_calls .= 0)) == 0
        return uncalled
    endif

    loop i=1..rows(n_function_calls)
        if n_function_calls[i] == 0
            uncalled += function_names[i]
        endif
    endloop

    return uncalled
end function

# TODO: test
function matrix summarize_graph (const matrix graph,
                                 const strings function_names)
    /* Get vector with n rows where each row refers to a function. The respective value refers to the number of calls if this specific function by other functions. This helps one to detect unused functions. */

    matrix m = sumr(graph)
    rnameset(m, function_names)
    cnameset(m, defarray("# Calls"))

    return m
end function

# TODO: test
function matrix compile_dependency_graph (const bundle Metadata)
    /* Compile a matrix of calls of a function (row) by some function (cols).
     Comlexity level is quadratic.*/

    matrix graph = zeros(nelem(Metadata), nelem(Metadata))

    loop foreach i Metadata
        string function_searched = sprintf("%s(", "$i")

        loop foreach j Metadata
            if ("$i" != "$j") && instring(Metadata["$j"].code, "$i")
                graph[i,j] = TRUE
            endif
        endloop
    endloop

    rnameset(graph, getkeys(Metadata))
    cnameset(graph, getkeys(Metadata))

    return graph
end function



function void print_pkgchecker (const bundle self "Bundle returned by get_pkgdata()")
    /* Print summary of functions. */

    strings function_names = getkeys(self)

    printf "\n============================================================\n"
    printf "\t\t%s\n\n", "Summary package function overview"
    printf "%-31s %5s %12s\n", "Function name", "# Input params.",\
        "Lines of Code"
    printf "-------------------------------------------------------------\n"

    loop foreach i function_names
        print_function_details(self["$i"], "$i")
    endloop
    printf "============================================================\n"
end function

function void print_function_details (const bundle Function,
                                      const string function_name)
    scalar n_lines = nelem(strsplit(Function.code, "\n")) # delimiter in xml
    scalar n_input = nelem(Function.parameter_names)
    n_input = (n_input > 0) ? n_input : 0

    printf "%-31s %5.d %18.d\n", function_name, n_input, n_lines
end function


function void printInfo (const string s)
    printf "\nInfo: %s\n", s
end function

function void printWarning (const string s)
    printf "\nWarning: %s\n", s
end function

function void printError (const string s)
    printf "\nError: %s\n", s
end function
