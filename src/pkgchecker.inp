function scalar is_minimum_gretl_version (void)
    if $version >= 20205
        return TRUE
    else
        printError("At minimum Gretl version 2020e required.")
        return FALSE
    endif
end function

# FROM metadata
function scalar read_and_add_xml_buffer (bundle *self)
    /* Read gdt file which has a xml structure. */

    catch self.xml_buffer = readfile(self.filename)
    if $error
        printError(sprintf("Failed to read file '%s'. Abort.\n", self.filename))
        return TRUE
    else
        return FALSE
    endif
end function

# TODO: Really needed here? I don't think so
function string trim_extra_lines (const string buffer)
    /* */

    if nelem(buffer) == 0
        return buffer
    endif
    strings content = strsplit(buffer, "\n")

    scalar n = nelem(content)
    if n == 1
        return content[n]
    endif

    return content
end function


function string get_function_path (void)
    /* Configure path which should be parsed. */

    return "//gretl-functions/gretl-function-package"
end function


# FROM metadata
function string get_path_content (const string path "xpath identifier",
                                  const string xml_buffer,
                                  scalar *n_got "Number of occurences of path")
    /* Extract content of some path in xml. */

    string path_content

    catch path_content = xmlget(xml_buffer, path, &n_got)
    if $error
        printWarning(sprintf("Failed to find the path '%s'. Ignore.", path))
    endif

    return path_content
end function

function scalar get_number_of_functions (const bundle self)
    /* Get number of functions of package. */

    scalar n_functions = 0
    scalar valid = TRUE
    scalar counter = 1

    loop while valid == TRUE
        scalar n_got = 0
        string path = get_path_code(get_function_path(), counter)
        string foo = get_path_content(path, self.xml_buffer, &n_got)

        if n_got
            n_functions++
            counter++
        else
            break
        endif
    endloop

    return n_functions
end function

function string get_path_code (const string function_path,
                               const int item[1::] "i-th function code")
    /* Compile path for retrieving code' for i-th function definition. */
    return sprintf("%s/gretl-function[%d]/code", function_path, item)
end function

function string get_path_code_name (const string function_path,
                                    const int item[1::] "i-th function code")
    /* Compile path for retrieving function's name for the i-th function definition. */
    return sprintf("%s/gretl-function[%d]/@name", function_path, item)
end function

function string get_code (const scalar item[1::] "i-th function code",
                          const bundle self)
    /* Retrieve function name for the i-th function. */

    scalar n_got = 0
    string path = get_path_code(get_function_path(), item)

    return get_path_content(path, self.xml_buffer, &n_got)
end function


function string get_path_count_parameters (const string function_path,
                                           const int item[1::] "i-th function code")
    return sprintf("%s/gretl-function[%d]/params/@count",\
                    function_path, item)
end function

function scalar get_number_of_parameters (const int item[1::],
                                          const bundle self)
    /* Get number of parameters for a specific functions. */

    scalar n_parameters = 0
    string path = get_path_count_parameters(get_function_path(), item)

    return atof(get_path_content(path, self.xml_buffer, &n_parameters))
end function

function string get_path_parameter_name (const string function_path,
                                         const int item[1::] "i-th function code",
                                         const int iparam[1::] "n-th parameter")
    /* Retrieve name of input parameter. */
    return sprintf("%s/gretl-function[%d]/params/param[%d]/@name",\
                    function_path, item, iparam)
end function


function strings get_parameter_names (const scalar item[1::] "i-th function",
                                      const bundle self)
    /* Retrieve function name for the i-th function. */

    scalar n_parameters = get_number_of_parameters(item, self)
    if ok(n_parameters)
        strings names = array(n_parameters)
    else
        return array(0) # function has void input
    endif

    loop i=1..n_parameters
        scalar n_got = 0
        string path = get_path_parameter_name(get_function_path(), item, i)
        names[i] = strstrip(get_path_content(path, self.xml_buffer, &n_got))
    endloop

    return names
end function



function string get_function_name (const scalar item[1::] "i-th function code",
                                   const bundle self)
    /* Retrieve function name for the i-th function. */

    scalar n_got = 0
    string path = get_path_code_name(get_function_path(), item)
    string function_name = get_path_content(path, self.xml_buffer, &n_got)

    return trim_extra_lines(function_name)
end function

function bundle extract_parameters (bundle Metadata,
                                    const bundle self)
    /* Extract input parameters for each function. */

    strings function_names = getkeys(Metadata)

    loop foreach i function_names
        Metadata["$i"].parameter_names = get_parameter_names(i, self)
    endloop

    return Metadata
end function


function bundle extract_code (const bundle self)
    /* Compile a key-value store.
    key: Function name
    value: String holding the i-th function code */

    bundle Codes
    scalar n_functions = get_number_of_functions(self)

    if n_functions == 0
        printWarning("Package includes no functions.")
        return Codes
    endif

    loop i=1..n_functions
        string function_name = get_function_name($i, self)

        if nelem(function_name) == 0
            printWarning("Function not found. Ignore.")
            flush
        else
            bundle Codes["@function_name"] = \
                        _(code = get_code($i, self))
        endif
    endloop

    assert(n_functions == nelem(Codes))

    return Codes
end function

function bundle get_pkgdata (const string filename "Path to gfn file")
    /* Main function */

    bundle self = null
    string self.filename = filename

    if !is_minimum_gretl_version()
        return null
    endif

    err = read_and_add_xml_buffer(&self)
    if err
        return null
    endif

    bundle Metadata = extract_code(self)
    if nelem(Metadata) == 0
        return self
    endif

    bundle Metadata = extract_parameters(Metadata, self)


    /*
    *** NEXT:
    A) Look at unused variables within a function
    1) Loop over each key (=function)
    2) Cast code for the i-th function as string array (\n as delimiter)
    3) extract assignments and check whether RHS variables is used
        somewhere or returned

    Codes (bundle)
        |-function_name1
            |-Code (string)
            |-parameter_names (string array)
                |- [Name1, Name2,..., NameN]
        |-function_name2
            |-Code (string)
            |-parameter_names (string array)
                |- [Name1, Name2,..., NameN]


    B) Apart from 'code' also parse names of params/param[i]/name
    1) Store 'name' as string array in Codes.input_parameters
    2) Loop over "code" and check whether input parameters are used in code

    C) For each function name (=key) iterate over code foreach other
        keys and check that the function is actually used somewhere. Of course,
        public functions won't be used within other functions...

    D) Write tests
    */

    eval getkeys(Metadata)[11]
    eval Metadata["print_auto_arima_results"]

    return Metadata
end function


function void printInfo (const string s)
    printf "\nInfo: %s\n", s
end function

function void printWarning (const string s)
    printf "\nWarning: %s\n", s
end function

function void printError (const string s)
    printf "\nError: %s\n", s
end function
